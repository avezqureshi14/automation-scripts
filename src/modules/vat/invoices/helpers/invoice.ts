import * as xlsx from 'xlsx';
import * as path from 'path';

export function buildFilters(orgName: string, startDate: string, endDate: string) {
    return JSON.stringify([
        ["company", "=", orgName],
        ["posting_date", "between", [startDate, endDate]]
    ]);
}

export function extractInvoiceNames(responseData: any) {
    return responseData.data?.data ?? [];
}

export function aggregateAmounts(response) {
    const aggregated = {};
    // Access the `data` array from the response
    const dataArray = response?.data;

    if (!Array.isArray(dataArray)) {
        throw new Error('Invalid data format: data is not an array.');
    }

    dataArray.forEach(item => {
        const { data: amounts } = item;

        for (const key in amounts) {
            if (!amounts.hasOwnProperty(key) || key.includes('profitScheme')) continue;

            if (!aggregated[key]) {
                aggregated[key] = 0;
            }

            aggregated[key] += parseFloat(amounts[key]);
        }
    });

    return aggregated;
}
export const mapInvoiceData = (inputData: any): any => {
    // Check if data exists and is an array with at least one element
    const { data } = inputData;

    if (!data || !Array.isArray(data) || data.length === 0) {
        throw new Error('Data is missing or empty.');
    }

    // If the check passes, proceed with accessing the first element
    const invoice = data[0].invoice;
    const invoiceData = data[0].data;

    const outputData = [
        {
            Col1: 'Invoice Details',
            Col2: JSON.stringify({
                UUID: invoice.invoiceId,
                ProfileID: 'UAE-VAT12345', // Static for now, can be dynamic if needed
                ID: invoice.invoiceId,
                IssueTime: invoice.createdOn,
                InvoiceTypeCode: 'Tax Invoice',
                DocumentCurrencyCode: 'AED',
                TaxCurrencyCode: 'AED',
                AdditionalDocumentReference: '',
                TaxCategoryID: null,
                TaxCategoryPercent: null,
                TaxCategoryTaxScheme: 'VAT',
            }),
        },
        {
            Col1: 'VAT on Sales and all other Outputs',
            Col2: JSON.stringify({
                '1a_Standard_rated_supplies_in_Abu_Dhabi': {
                    Amount_AED: invoiceData.amount1a,
                    VAT_Amount_AED: Number(invoiceData.amount1a),
                    Adjustment_Amount_AED: invoiceData.adjustment1a,
                },
                '1b_Standard_rated_supplies_in_Dubai': {
                    Amount_AED: invoiceData.amount1b,
                    VAT_Amount_AED: Number(invoiceData.amount1b),
                    Adjustment_Amount_AED: invoiceData.adjustment1b,
                },
                // Continue with the rest of the outputData structure
            }),
        },
        // Continue with the other sections of outputData
    ];

    return { outputData, invoiceId: invoice.invoiceId };
};


export function detectChanges(oldData, newData) {
    // Parse JSON strings into objects
    const oldObj = JSON.parse(oldData);
    const newObj = JSON.parse(newData);

    const changes = [];

    function compareObjects(obj1, obj2, path = '') {
        // Iterate over keys in the first object
        for (const key in obj1) {
            const currentPath = path ? `${path}.${key}` : key;

            if (typeof obj1[key] === 'object' && obj1[key] !== null) {
                // Recursively compare nested objects
                compareObjects(obj1[key], obj2[key] || {}, currentPath);
            } else {
                // Check if the key exists in the second object and if the values are different
                if (obj1[key] !== obj2[key]) {
                    changes.push({
                        path: currentPath,
                        oldValue: obj1[key],
                        newValue: obj2[key] !== undefined ? obj2[key] : 'Key missing in new data',
                    });
                }
            }
        }
    }

    // Start comparison
    compareObjects(oldObj, newObj);

    return changes;
}

export function generateReport(inputData, miscellData) {
    const fieldMaxLength = 40; // Max length for the field path
    const data = [];

    data.push(['Invoice ID', miscellData.invoiceId]);
    data.push(['Generated By', miscellData.generatedBy]);
    data.push(['Generated On', miscellData.generatedOn]);
    data.push(['Rectification Date', miscellData.rectifiedOn]);

    // Add a row space after the static fields
    data.push([]);

    // Add table headers
    data.push(['Field Path', 'Original Value', 'Updated Value']);

    // Add the changes data
    inputData.forEach(change => {
        const field = splitFieldPath(change.path, fieldMaxLength);
        const oldValue = String(change.oldValue);
        const newValue = String(change.newValue);

        // Add each line of the field path to the data array
        field.forEach(line => {
            data.push([line, oldValue, newValue]);
        });
    });

    // Create a new workbook and add the data
    const ws = xlsx.utils.aoa_to_sheet(data);
    const wb = xlsx.utils.book_new();
    const timestamp = new Date().toISOString().replace(/[-:.]/g, '_');
    const sheetName = `Invoice_Rectification_Report_${timestamp}`.slice(0, 31);

    // Append the sheet to the workbook
    xlsx.utils.book_append_sheet(wb, ws, sheetName);

    // Generate file path and write the file
    const filePath = path.join(__dirname, `${sheetName}.xlsx`);
    xlsx.writeFile(wb, filePath);


    return filePath;
}

// Helper function to split long field paths into multiple lines
function splitFieldPath(fieldPath, maxLength) {
    const lines = [];
    while (fieldPath.length > maxLength) {
        lines.push(fieldPath.substring(0, maxLength));
        fieldPath = fieldPath.substring(maxLength);
    }
    if (fieldPath.length > 0) {
        lines.push(fieldPath);
    }
    return lines;
}